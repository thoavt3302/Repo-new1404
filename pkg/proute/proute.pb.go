// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: proute.proto

package proute

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strings "strings"

	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// UUIDCrumb implements a crumb that renders a uuid when called
type UUIDCrumb struct {
	Name string `protobuf:"bytes,1,opt,name=Name,proto3" json:"Name,omitempty"`
}

func (m *UUIDCrumb) Reset()      { *m = UUIDCrumb{} }
func (*UUIDCrumb) ProtoMessage() {}
func (*UUIDCrumb) Descriptor() ([]byte, []int) {
	return fileDescriptor_ea0b90b390d3b351, []int{0}
}
func (m *UUIDCrumb) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UUIDCrumb) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UUIDCrumb.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UUIDCrumb) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UUIDCrumb.Merge(m, src)
}
func (m *UUIDCrumb) XXX_Size() int {
	return m.Size()
}
func (m *UUIDCrumb) XXX_DiscardUnknown() {
	xxx_messageInfo_UUIDCrumb.DiscardUnknown(m)
}

var xxx_messageInfo_UUIDCrumb proto.InternalMessageInfo

func (m *UUIDCrumb) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// StaticCrumb implements a crumb that renders a static value when called
type StaticCrumb struct {
	K string `protobuf:"bytes,1,opt,name=K,proto3" json:"K,omitempty"`
	V string `protobuf:"bytes,2,opt,name=V,proto3" json:"V,omitempty"`
}

func (m *StaticCrumb) Reset()      { *m = StaticCrumb{} }
func (*StaticCrumb) ProtoMessage() {}
func (*StaticCrumb) Descriptor() ([]byte, []int) {
	return fileDescriptor_ea0b90b390d3b351, []int{1}
}
func (m *StaticCrumb) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StaticCrumb) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StaticCrumb.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StaticCrumb) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StaticCrumb.Merge(m, src)
}
func (m *StaticCrumb) XXX_Size() int {
	return m.Size()
}
func (m *StaticCrumb) XXX_DiscardUnknown() {
	xxx_messageInfo_StaticCrumb.DiscardUnknown(m)
}

var xxx_messageInfo_StaticCrumb proto.InternalMessageInfo

func (m *StaticCrumb) GetK() string {
	if m != nil {
		return m.K
	}
	return ""
}

func (m *StaticCrumb) GetV() string {
	if m != nil {
		return m.V
	}
	return ""
}

type IntCrumb struct {
	Min   int64  `protobuf:"varint,1,opt,name=Min,proto3" json:"Min,omitempty"`
	Max   int64  `protobuf:"varint,2,opt,name=Max,proto3" json:"Max,omitempty"`
	Val   int64  `protobuf:"varint,3,opt,name=Val,proto3" json:"Val,omitempty"`
	Fixed bool   `protobuf:"varint,4,opt,name=Fixed,proto3" json:"Fixed,omitempty"`
	Name  string `protobuf:"bytes,5,opt,name=Name,proto3" json:"Name,omitempty"`
}

func (m *IntCrumb) Reset()      { *m = IntCrumb{} }
func (*IntCrumb) ProtoMessage() {}
func (*IntCrumb) Descriptor() ([]byte, []int) {
	return fileDescriptor_ea0b90b390d3b351, []int{2}
}
func (m *IntCrumb) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IntCrumb) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IntCrumb.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IntCrumb) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IntCrumb.Merge(m, src)
}
func (m *IntCrumb) XXX_Size() int {
	return m.Size()
}
func (m *IntCrumb) XXX_DiscardUnknown() {
	xxx_messageInfo_IntCrumb.DiscardUnknown(m)
}

var xxx_messageInfo_IntCrumb proto.InternalMessageInfo

func (m *IntCrumb) GetMin() int64 {
	if m != nil {
		return m.Min
	}
	return 0
}

func (m *IntCrumb) GetMax() int64 {
	if m != nil {
		return m.Max
	}
	return 0
}

func (m *IntCrumb) GetVal() int64 {
	if m != nil {
		return m.Val
	}
	return 0
}

func (m *IntCrumb) GetFixed() bool {
	if m != nil {
		return m.Fixed
	}
	return false
}

func (m *IntCrumb) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type BoolCrumb struct {
	Name  string `protobuf:"bytes,1,opt,name=Name,proto3" json:"Name,omitempty"`
	Fixed bool   `protobuf:"varint,2,opt,name=Fixed,proto3" json:"Fixed,omitempty"`
	Val   bool   `protobuf:"varint,3,opt,name=Val,proto3" json:"Val,omitempty"`
}

func (m *BoolCrumb) Reset()      { *m = BoolCrumb{} }
func (*BoolCrumb) ProtoMessage() {}
func (*BoolCrumb) Descriptor() ([]byte, []int) {
	return fileDescriptor_ea0b90b390d3b351, []int{3}
}
func (m *BoolCrumb) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BoolCrumb) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BoolCrumb.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BoolCrumb) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BoolCrumb.Merge(m, src)
}
func (m *BoolCrumb) XXX_Size() int {
	return m.Size()
}
func (m *BoolCrumb) XXX_DiscardUnknown() {
	xxx_messageInfo_BoolCrumb.DiscardUnknown(m)
}

var xxx_messageInfo_BoolCrumb proto.InternalMessageInfo

func (m *BoolCrumb) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *BoolCrumb) GetFixed() bool {
	if m != nil {
		return m.Fixed
	}
	return false
}

func (m *BoolCrumb) GetVal() bool {
	if m != nil {
		return m.Val
	}
	return false
}

type FloatCrumb struct {
	Name  string  `protobuf:"bytes,1,opt,name=Name,proto3" json:"Name,omitempty"`
	Fixed bool    `protobuf:"varint,2,opt,name=Fixed,proto3" json:"Fixed,omitempty"`
	Val   float64 `protobuf:"fixed64,3,opt,name=Val,proto3" json:"Val,omitempty"`
}

func (m *FloatCrumb) Reset()      { *m = FloatCrumb{} }
func (*FloatCrumb) ProtoMessage() {}
func (*FloatCrumb) Descriptor() ([]byte, []int) {
	return fileDescriptor_ea0b90b390d3b351, []int{4}
}
func (m *FloatCrumb) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FloatCrumb) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FloatCrumb.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FloatCrumb) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FloatCrumb.Merge(m, src)
}
func (m *FloatCrumb) XXX_Size() int {
	return m.Size()
}
func (m *FloatCrumb) XXX_DiscardUnknown() {
	xxx_messageInfo_FloatCrumb.DiscardUnknown(m)
}

var xxx_messageInfo_FloatCrumb proto.InternalMessageInfo

func (m *FloatCrumb) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *FloatCrumb) GetFixed() bool {
	if m != nil {
		return m.Fixed
	}
	return false
}

func (m *FloatCrumb) GetVal() float64 {
	if m != nil {
		return m.Val
	}
	return 0
}

// RandomStringCrumb will return a random string of specified length with the specified charset
type RandomStringCrumb struct {
	Name    string `protobuf:"bytes,1,opt,name=Name,proto3" json:"Name,omitempty"`
	Charset string `protobuf:"bytes,2,opt,name=Charset,proto3" json:"Charset,omitempty"`
	Length  int    `protobuf:"varint,3,opt,name=Length,proto3,casttype=int" json:"Length,omitempty"`
}

func (m *RandomStringCrumb) Reset()      { *m = RandomStringCrumb{} }
func (*RandomStringCrumb) ProtoMessage() {}
func (*RandomStringCrumb) Descriptor() ([]byte, []int) {
	return fileDescriptor_ea0b90b390d3b351, []int{5}
}
func (m *RandomStringCrumb) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RandomStringCrumb) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RandomStringCrumb.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RandomStringCrumb) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RandomStringCrumb.Merge(m, src)
}
func (m *RandomStringCrumb) XXX_Size() int {
	return m.Size()
}
func (m *RandomStringCrumb) XXX_DiscardUnknown() {
	xxx_messageInfo_RandomStringCrumb.DiscardUnknown(m)
}

var xxx_messageInfo_RandomStringCrumb proto.InternalMessageInfo

func (m *RandomStringCrumb) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *RandomStringCrumb) GetCharset() string {
	if m != nil {
		return m.Charset
	}
	return ""
}

func (m *RandomStringCrumb) GetLength() int {
	if m != nil {
		return m.Length
	}
	return 0
}

// RegexStringCrumb will generate a string based off a provided regex
type RegexStringCrumb struct {
	Name  string `protobuf:"bytes,1,opt,name=Name,proto3" json:"Name,omitempty"`
	Regex string `protobuf:"bytes,2,opt,name=Regex,proto3" json:"Regex,omitempty"`
}

func (m *RegexStringCrumb) Reset()      { *m = RegexStringCrumb{} }
func (*RegexStringCrumb) ProtoMessage() {}
func (*RegexStringCrumb) Descriptor() ([]byte, []int) {
	return fileDescriptor_ea0b90b390d3b351, []int{6}
}
func (m *RegexStringCrumb) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RegexStringCrumb) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RegexStringCrumb.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RegexStringCrumb) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RegexStringCrumb.Merge(m, src)
}
func (m *RegexStringCrumb) XXX_Size() int {
	return m.Size()
}
func (m *RegexStringCrumb) XXX_DiscardUnknown() {
	xxx_messageInfo_RegexStringCrumb.DiscardUnknown(m)
}

var xxx_messageInfo_RegexStringCrumb proto.InternalMessageInfo

func (m *RegexStringCrumb) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *RegexStringCrumb) GetRegex() string {
	if m != nil {
		return m.Regex
	}
	return ""
}

type BasicAuthCrumb struct {
	Name     string `protobuf:"bytes,1,opt,name=Name,proto3" json:"Name,omitempty"`
	User     string `protobuf:"bytes,2,opt,name=User,proto3" json:"User,omitempty"`
	Password string `protobuf:"bytes,3,opt,name=Password,proto3" json:"Password,omitempty"`
	Random   bool   `protobuf:"varint,4,opt,name=Random,proto3" json:"Random,omitempty"`
}

func (m *BasicAuthCrumb) Reset()      { *m = BasicAuthCrumb{} }
func (*BasicAuthCrumb) ProtoMessage() {}
func (*BasicAuthCrumb) Descriptor() ([]byte, []int) {
	return fileDescriptor_ea0b90b390d3b351, []int{7}
}
func (m *BasicAuthCrumb) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BasicAuthCrumb) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BasicAuthCrumb.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BasicAuthCrumb) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BasicAuthCrumb.Merge(m, src)
}
func (m *BasicAuthCrumb) XXX_Size() int {
	return m.Size()
}
func (m *BasicAuthCrumb) XXX_DiscardUnknown() {
	xxx_messageInfo_BasicAuthCrumb.DiscardUnknown(m)
}

var xxx_messageInfo_BasicAuthCrumb proto.InternalMessageInfo

func (m *BasicAuthCrumb) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *BasicAuthCrumb) GetUser() string {
	if m != nil {
		return m.User
	}
	return ""
}

func (m *BasicAuthCrumb) GetPassword() string {
	if m != nil {
		return m.Password
	}
	return ""
}

func (m *BasicAuthCrumb) GetRandom() bool {
	if m != nil {
		return m.Random
	}
	return false
}

type ProtoArrayCrumb struct {
	Name    string      `protobuf:"bytes,1,opt,name=Name,proto3" json:"Name,omitempty"`
	Element *ProtoCrumb `protobuf:"bytes,2,opt,name=Element,proto3" json:"Element,omitempty"`
}

func (m *ProtoArrayCrumb) Reset()      { *m = ProtoArrayCrumb{} }
func (*ProtoArrayCrumb) ProtoMessage() {}
func (*ProtoArrayCrumb) Descriptor() ([]byte, []int) {
	return fileDescriptor_ea0b90b390d3b351, []int{8}
}
func (m *ProtoArrayCrumb) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProtoArrayCrumb) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProtoArrayCrumb.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProtoArrayCrumb) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProtoArrayCrumb.Merge(m, src)
}
func (m *ProtoArrayCrumb) XXX_Size() int {
	return m.Size()
}
func (m *ProtoArrayCrumb) XXX_DiscardUnknown() {
	xxx_messageInfo_ProtoArrayCrumb.DiscardUnknown(m)
}

var xxx_messageInfo_ProtoArrayCrumb proto.InternalMessageInfo

func (m *ProtoArrayCrumb) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ProtoArrayCrumb) GetElement() *ProtoCrumb {
	if m != nil {
		return m.Element
	}
	return nil
}

type ProtoObjectCrumb struct {
	Name     string       `protobuf:"bytes,1,opt,name=Name,proto3" json:"Name,omitempty"`
	Elements []ProtoCrumb `protobuf:"bytes,2,rep,name=Elements,proto3" json:"Elements"`
}

func (m *ProtoObjectCrumb) Reset()      { *m = ProtoObjectCrumb{} }
func (*ProtoObjectCrumb) ProtoMessage() {}
func (*ProtoObjectCrumb) Descriptor() ([]byte, []int) {
	return fileDescriptor_ea0b90b390d3b351, []int{9}
}
func (m *ProtoObjectCrumb) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProtoObjectCrumb) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProtoObjectCrumb.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProtoObjectCrumb) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProtoObjectCrumb.Merge(m, src)
}
func (m *ProtoObjectCrumb) XXX_Size() int {
	return m.Size()
}
func (m *ProtoObjectCrumb) XXX_DiscardUnknown() {
	xxx_messageInfo_ProtoObjectCrumb.DiscardUnknown(m)
}

var xxx_messageInfo_ProtoObjectCrumb proto.InternalMessageInfo

func (m *ProtoObjectCrumb) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ProtoObjectCrumb) GetElements() []ProtoCrumb {
	if m != nil {
		return m.Elements
	}
	return nil
}

// StringCrumbCrumb is a crumb that will generate the value of its child, then wrap it in a string
type ProtoStringCrumbCrumb struct {
	Name  string      `protobuf:"bytes,1,opt,name=Name,proto3" json:"Name,omitempty"`
	Child *ProtoCrumb `protobuf:"bytes,2,opt,name=Child,proto3" json:"Child,omitempty"`
}

func (m *ProtoStringCrumbCrumb) Reset()      { *m = ProtoStringCrumbCrumb{} }
func (*ProtoStringCrumbCrumb) ProtoMessage() {}
func (*ProtoStringCrumbCrumb) Descriptor() ([]byte, []int) {
	return fileDescriptor_ea0b90b390d3b351, []int{10}
}
func (m *ProtoStringCrumbCrumb) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProtoStringCrumbCrumb) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProtoStringCrumbCrumb.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProtoStringCrumbCrumb) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProtoStringCrumbCrumb.Merge(m, src)
}
func (m *ProtoStringCrumbCrumb) XXX_Size() int {
	return m.Size()
}
func (m *ProtoStringCrumbCrumb) XXX_DiscardUnknown() {
	xxx_messageInfo_ProtoStringCrumbCrumb.DiscardUnknown(m)
}

var xxx_messageInfo_ProtoStringCrumbCrumb proto.InternalMessageInfo

func (m *ProtoStringCrumbCrumb) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ProtoStringCrumbCrumb) GetChild() *ProtoCrumb {
	if m != nil {
		return m.Child
	}
	return nil
}

type ProtoCrumb struct {
	// Types that are valid to be assigned to Crumb:
	//	*ProtoCrumb_UuidCrumb
	//	*ProtoCrumb_StaticCrumb
	//	*ProtoCrumb_IntCrumb
	//	*ProtoCrumb_BoolCrumb
	//	*ProtoCrumb_FloatCrumb
	//	*ProtoCrumb_RandomStringCrumb
	//	*ProtoCrumb_RegexStringCrumb
	//	*ProtoCrumb_BasicAuthCrumb
	//	*ProtoCrumb_ArrayCrumb
	//	*ProtoCrumb_ObjectCrumb
	//	*ProtoCrumb_StringCrumbCrumb
	Crumb isProtoCrumb_Crumb `protobuf_oneof:"crumb"`
}

func (m *ProtoCrumb) Reset()      { *m = ProtoCrumb{} }
func (*ProtoCrumb) ProtoMessage() {}
func (*ProtoCrumb) Descriptor() ([]byte, []int) {
	return fileDescriptor_ea0b90b390d3b351, []int{11}
}
func (m *ProtoCrumb) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProtoCrumb) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProtoCrumb.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProtoCrumb) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProtoCrumb.Merge(m, src)
}
func (m *ProtoCrumb) XXX_Size() int {
	return m.Size()
}
func (m *ProtoCrumb) XXX_DiscardUnknown() {
	xxx_messageInfo_ProtoCrumb.DiscardUnknown(m)
}

var xxx_messageInfo_ProtoCrumb proto.InternalMessageInfo

type isProtoCrumb_Crumb interface {
	isProtoCrumb_Crumb()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type ProtoCrumb_UuidCrumb struct {
	UuidCrumb *UUIDCrumb `protobuf:"bytes,1,opt,name=uuidCrumb,proto3,oneof" json:"uuidCrumb,omitempty"`
}
type ProtoCrumb_StaticCrumb struct {
	StaticCrumb *StaticCrumb `protobuf:"bytes,2,opt,name=staticCrumb,proto3,oneof" json:"staticCrumb,omitempty"`
}
type ProtoCrumb_IntCrumb struct {
	IntCrumb *IntCrumb `protobuf:"bytes,3,opt,name=intCrumb,proto3,oneof" json:"intCrumb,omitempty"`
}
type ProtoCrumb_BoolCrumb struct {
	BoolCrumb *BoolCrumb `protobuf:"bytes,4,opt,name=boolCrumb,proto3,oneof" json:"boolCrumb,omitempty"`
}
type ProtoCrumb_FloatCrumb struct {
	FloatCrumb *FloatCrumb `protobuf:"bytes,5,opt,name=floatCrumb,proto3,oneof" json:"floatCrumb,omitempty"`
}
type ProtoCrumb_RandomStringCrumb struct {
	RandomStringCrumb *RandomStringCrumb `protobuf:"bytes,6,opt,name=randomStringCrumb,proto3,oneof" json:"randomStringCrumb,omitempty"`
}
type ProtoCrumb_RegexStringCrumb struct {
	RegexStringCrumb *RegexStringCrumb `protobuf:"bytes,7,opt,name=regexStringCrumb,proto3,oneof" json:"regexStringCrumb,omitempty"`
}
type ProtoCrumb_BasicAuthCrumb struct {
	BasicAuthCrumb *BasicAuthCrumb `protobuf:"bytes,8,opt,name=basicAuthCrumb,proto3,oneof" json:"basicAuthCrumb,omitempty"`
}
type ProtoCrumb_ArrayCrumb struct {
	ArrayCrumb *ProtoArrayCrumb `protobuf:"bytes,9,opt,name=arrayCrumb,proto3,oneof" json:"arrayCrumb,omitempty"`
}
type ProtoCrumb_ObjectCrumb struct {
	ObjectCrumb *ProtoObjectCrumb `protobuf:"bytes,10,opt,name=objectCrumb,proto3,oneof" json:"objectCrumb,omitempty"`
}
type ProtoCrumb_StringCrumbCrumb struct {
	StringCrumbCrumb *ProtoStringCrumbCrumb `protobuf:"bytes,11,opt,name=stringCrumbCrumb,proto3,oneof" json:"stringCrumbCrumb,omitempty"`
}

func (*ProtoCrumb_UuidCrumb) isProtoCrumb_Crumb()         {}
func (*ProtoCrumb_StaticCrumb) isProtoCrumb_Crumb()       {}
func (*ProtoCrumb_IntCrumb) isProtoCrumb_Crumb()          {}
func (*ProtoCrumb_BoolCrumb) isProtoCrumb_Crumb()         {}
func (*ProtoCrumb_FloatCrumb) isProtoCrumb_Crumb()        {}
func (*ProtoCrumb_RandomStringCrumb) isProtoCrumb_Crumb() {}
func (*ProtoCrumb_RegexStringCrumb) isProtoCrumb_Crumb()  {}
func (*ProtoCrumb_BasicAuthCrumb) isProtoCrumb_Crumb()    {}
func (*ProtoCrumb_ArrayCrumb) isProtoCrumb_Crumb()        {}
func (*ProtoCrumb_ObjectCrumb) isProtoCrumb_Crumb()       {}
func (*ProtoCrumb_StringCrumbCrumb) isProtoCrumb_Crumb()  {}

func (m *ProtoCrumb) GetCrumb() isProtoCrumb_Crumb {
	if m != nil {
		return m.Crumb
	}
	return nil
}

func (m *ProtoCrumb) GetUuidCrumb() *UUIDCrumb {
	if x, ok := m.GetCrumb().(*ProtoCrumb_UuidCrumb); ok {
		return x.UuidCrumb
	}
	return nil
}

func (m *ProtoCrumb) GetStaticCrumb() *StaticCrumb {
	if x, ok := m.GetCrumb().(*ProtoCrumb_StaticCrumb); ok {
		return x.StaticCrumb
	}
	return nil
}

func (m *ProtoCrumb) GetIntCrumb() *IntCrumb {
	if x, ok := m.GetCrumb().(*ProtoCrumb_IntCrumb); ok {
		return x.IntCrumb
	}
	return nil
}

func (m *ProtoCrumb) GetBoolCrumb() *BoolCrumb {
	if x, ok := m.GetCrumb().(*ProtoCrumb_BoolCrumb); ok {
		return x.BoolCrumb
	}
	return nil
}

func (m *ProtoCrumb) GetFloatCrumb() *FloatCrumb {
	if x, ok := m.GetCrumb().(*ProtoCrumb_FloatCrumb); ok {
		return x.FloatCrumb
	}
	return nil
}

func (m *ProtoCrumb) GetRandomStringCrumb() *RandomStringCrumb {
	if x, ok := m.GetCrumb().(*ProtoCrumb_RandomStringCrumb); ok {
		return x.RandomStringCrumb
	}
	return nil
}

func (m *ProtoCrumb) GetRegexStringCrumb() *RegexStringCrumb {
	if x, ok := m.GetCrumb().(*ProtoCrumb_RegexStringCrumb); ok {
		return x.RegexStringCrumb
	}
	return nil
}

func (m *ProtoCrumb) GetBasicAuthCrumb() *BasicAuthCrumb {
	if x, ok := m.GetCrumb().(*ProtoCrumb_BasicAuthCrumb); ok {
		return x.BasicAuthCrumb
	}
	return nil
}

func (m *ProtoCrumb) GetArrayCrumb() *ProtoArrayCrumb {
	if x, ok := m.GetCrumb().(*ProtoCrumb_ArrayCrumb); ok {
		return x.ArrayCrumb
	}
	return nil
}

func (m *ProtoCrumb) GetObjectCrumb() *ProtoObjectCrumb {
	if x, ok := m.GetCrumb().(*ProtoCrumb_ObjectCrumb); ok {
		return x.ObjectCrumb
	}
	return nil
}

func (m *ProtoCrumb) GetStringCrumbCrumb() *ProtoStringCrumbCrumb {
	if x, ok := m.GetCrumb().(*ProtoCrumb_StringCrumbCrumb); ok {
		return x.StringCrumbCrumb
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ProtoCrumb) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ProtoCrumb_UuidCrumb)(nil),
		(*ProtoCrumb_StaticCrumb)(nil),
		(*ProtoCrumb_IntCrumb)(nil),
		(*ProtoCrumb_BoolCrumb)(nil),
		(*ProtoCrumb_FloatCrumb)(nil),
		(*ProtoCrumb_RandomStringCrumb)(nil),
		(*ProtoCrumb_RegexStringCrumb)(nil),
		(*ProtoCrumb_BasicAuthCrumb)(nil),
		(*ProtoCrumb_ArrayCrumb)(nil),
		(*ProtoCrumb_ObjectCrumb)(nil),
		(*ProtoCrumb_StringCrumbCrumb)(nil),
	}
}

type ProtoRoute struct {
	TemplatePath string        `protobuf:"bytes,1,opt,name=TemplatePath,proto3" json:"TemplatePath,omitempty"`
	Method       string        `protobuf:"bytes,2,opt,name=Method,proto3" json:"Method,omitempty"`
	PathCrumbs   []ProtoCrumb  `protobuf:"bytes,3,rep,name=PathCrumbs,proto3" json:"PathCrumbs"`
	HeaderCrumbs []ProtoCrumb  `protobuf:"bytes,4,rep,name=HeaderCrumbs,proto3" json:"HeaderCrumbs"`
	QueryCrumbs  []ProtoCrumb  `protobuf:"bytes,5,rep,name=QueryCrumbs,proto3" json:"QueryCrumbs"`
	BodyCrumbs   []ProtoCrumb  `protobuf:"bytes,6,rep,name=BodyCrumbs,proto3" json:"BodyCrumbs"`
	ContentType  []ContentType `protobuf:"bytes,7,rep,name=ContentType,proto3,casttype=ContentType" json:"ContentType,omitempty"`
}

func (m *ProtoRoute) Reset()      { *m = ProtoRoute{} }
func (*ProtoRoute) ProtoMessage() {}
func (*ProtoRoute) Descriptor() ([]byte, []int) {
	return fileDescriptor_ea0b90b390d3b351, []int{12}
}
func (m *ProtoRoute) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProtoRoute) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProtoRoute.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProtoRoute) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProtoRoute.Merge(m, src)
}
func (m *ProtoRoute) XXX_Size() int {
	return m.Size()
}
func (m *ProtoRoute) XXX_DiscardUnknown() {
	xxx_messageInfo_ProtoRoute.DiscardUnknown(m)
}

var xxx_messageInfo_ProtoRoute proto.InternalMessageInfo

func (m *ProtoRoute) GetTemplatePath() string {
	if m != nil {
		return m.TemplatePath
	}
	return ""
}

func (m *ProtoRoute) GetMethod() string {
	if m != nil {
		return m.Method
	}
	return ""
}

func (m *ProtoRoute) GetPathCrumbs() []ProtoCrumb {
	if m != nil {
		return m.PathCrumbs
	}
	return nil
}

func (m *ProtoRoute) GetHeaderCrumbs() []ProtoCrumb {
	if m != nil {
		return m.HeaderCrumbs
	}
	return nil
}

func (m *ProtoRoute) GetQueryCrumbs() []ProtoCrumb {
	if m != nil {
		return m.QueryCrumbs
	}
	return nil
}

func (m *ProtoRoute) GetBodyCrumbs() []ProtoCrumb {
	if m != nil {
		return m.BodyCrumbs
	}
	return nil
}

func (m *ProtoRoute) GetContentType() []ContentType {
	if m != nil {
		return m.ContentType
	}
	return nil
}

type ProtoAPI struct {
	URL          string       `protobuf:"bytes,1,opt,name=URL,proto3" json:"URL,omitempty"`
	ID           string       `protobuf:"bytes,2,opt,name=ID,proto3" json:"ID,omitempty"`
	Routes       []ProtoRoute `protobuf:"bytes,3,rep,name=Routes,proto3" json:"Routes"`
	HeaderCrumbs []ProtoCrumb `protobuf:"bytes,4,rep,name=HeaderCrumbs,proto3" json:"HeaderCrumbs"`
	QueryCrumbs  []ProtoCrumb `protobuf:"bytes,5,rep,name=QueryCrumbs,proto3" json:"QueryCrumbs"`
	BodyCrumbs   []ProtoCrumb `protobuf:"bytes,6,rep,name=BodyCrumbs,proto3" json:"BodyCrumbs"`
	CookieCrumbs []ProtoCrumb `protobuf:"bytes,7,rep,name=CookieCrumbs,proto3" json:"CookieCrumbs"`
}

func (m *ProtoAPI) Reset()      { *m = ProtoAPI{} }
func (*ProtoAPI) ProtoMessage() {}
func (*ProtoAPI) Descriptor() ([]byte, []int) {
	return fileDescriptor_ea0b90b390d3b351, []int{13}
}
func (m *ProtoAPI) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProtoAPI) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProtoAPI.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProtoAPI) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProtoAPI.Merge(m, src)
}
func (m *ProtoAPI) XXX_Size() int {
	return m.Size()
}
func (m *ProtoAPI) XXX_DiscardUnknown() {
	xxx_messageInfo_ProtoAPI.DiscardUnknown(m)
}

var xxx_messageInfo_ProtoAPI proto.InternalMessageInfo

func (m *ProtoAPI) GetURL() string {
	if m != nil {
		return m.URL
	}
	return ""
}

func (m *ProtoAPI) GetID() string {
	if m != nil {
		return m.ID
	}
	return ""
}

func (m *ProtoAPI) GetRoutes() []ProtoRoute {
	if m != nil {
		return m.Routes
	}
	return nil
}

func (m *ProtoAPI) GetHeaderCrumbs() []ProtoCrumb {
	if m != nil {
		return m.HeaderCrumbs
	}
	return nil
}

func (m *ProtoAPI) GetQueryCrumbs() []ProtoCrumb {
	if m != nil {
		return m.QueryCrumbs
	}
	return nil
}

func (m *ProtoAPI) GetBodyCrumbs() []ProtoCrumb {
	if m != nil {
		return m.BodyCrumbs
	}
	return nil
}

func (m *ProtoAPI) GetCookieCrumbs() []ProtoCrumb {
	if m != nil {
		return m.CookieCrumbs
	}
	return nil
}

type ProtoAPIS struct {
	APIs []ProtoAPI `protobuf:"bytes,1,rep,name=APIs,proto3" json:"APIs"`
}

func (m *ProtoAPIS) Reset()      { *m = ProtoAPIS{} }
func (*ProtoAPIS) ProtoMessage() {}
func (*ProtoAPIS) Descriptor() ([]byte, []int) {
	return fileDescriptor_ea0b90b390d3b351, []int{14}
}
func (m *ProtoAPIS) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProtoAPIS) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProtoAPIS.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProtoAPIS) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProtoAPIS.Merge(m, src)
}
func (m *ProtoAPIS) XXX_Size() int {
	return m.Size()
}
func (m *ProtoAPIS) XXX_DiscardUnknown() {
	xxx_messageInfo_ProtoAPIS.DiscardUnknown(m)
}

var xxx_messageInfo_ProtoAPIS proto.InternalMessageInfo

func (m *ProtoAPIS) GetAPIs() []ProtoAPI {
	if m != nil {
		return m.APIs
	}
	return nil
}

func init() {
	proto.RegisterType((*UUIDCrumb)(nil), "proute.UUIDCrumb")
	proto.RegisterType((*StaticCrumb)(nil), "proute.StaticCrumb")
	proto.RegisterType((*IntCrumb)(nil), "proute.IntCrumb")
	proto.RegisterType((*BoolCrumb)(nil), "proute.BoolCrumb")
	proto.RegisterType((*FloatCrumb)(nil), "proute.FloatCrumb")
	proto.RegisterType((*RandomStringCrumb)(nil), "proute.RandomStringCrumb")
	proto.RegisterType((*RegexStringCrumb)(nil), "proute.RegexStringCrumb")
	proto.RegisterType((*BasicAuthCrumb)(nil), "proute.BasicAuthCrumb")
	proto.RegisterType((*ProtoArrayCrumb)(nil), "proute.ProtoArrayCrumb")
	proto.RegisterType((*ProtoObjectCrumb)(nil), "proute.ProtoObjectCrumb")
	proto.RegisterType((*ProtoStringCrumbCrumb)(nil), "proute.ProtoStringCrumbCrumb")
	proto.RegisterType((*ProtoCrumb)(nil), "proute.ProtoCrumb")
	proto.RegisterType((*ProtoRoute)(nil), "proute.ProtoRoute")
	proto.RegisterType((*ProtoAPI)(nil), "proute.ProtoAPI")
	proto.RegisterType((*ProtoAPIS)(nil), "proute.ProtoAPIS")
}

func init() { proto.RegisterFile("proute.proto", fileDescriptor_ea0b90b390d3b351) }

var fileDescriptor_ea0b90b390d3b351 = []byte{
	// 946 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xd4, 0x56, 0xcd, 0x72, 0x1b, 0x45,
	0x10, 0xde, 0xd5, 0xbf, 0x7a, 0x55, 0x8e, 0x3c, 0x84, 0xb0, 0xa4, 0x8a, 0x95, 0x6b, 0x4f, 0x26,
	0x05, 0x16, 0x31, 0xa9, 0x0a, 0x50, 0x3e, 0x60, 0xc9, 0x98, 0x55, 0x39, 0x01, 0x31, 0x8e, 0x7c,
	0xa0, 0x38, 0x30, 0x92, 0x26, 0xd2, 0xc6, 0xd2, 0x8e, 0x6a, 0x77, 0xb6, 0xb0, 0x6f, 0x3c, 0x02,
	0x8f, 0xc1, 0x0b, 0xf0, 0x0e, 0x39, 0xea, 0x98, 0x93, 0x0b, 0xcb, 0x17, 0xb8, 0xe5, 0x9c, 0x13,
	0x35, 0xb3, 0xb3, 0x3f, 0x92, 0xa3, 0xe8, 0xc0, 0x29, 0xb7, 0xe9, 0x9e, 0xef, 0xfb, 0xba, 0xdd,
	0xd3, 0x9f, 0xbc, 0x50, 0x9b, 0xf9, 0x2c, 0xe4, 0x74, 0x6f, 0xe6, 0x33, 0xce, 0x50, 0x29, 0x8a,
	0xee, 0x7f, 0x3e, 0x72, 0xf9, 0x38, 0xec, 0xef, 0x0d, 0xd8, 0xb4, 0x39, 0x62, 0x23, 0xd6, 0x94,
	0xd7, 0xfd, 0xf0, 0xb9, 0x8c, 0x64, 0x20, 0x4f, 0x11, 0xcd, 0x6e, 0x40, 0xb5, 0xd7, 0xeb, 0x1c,
	0xb5, 0xfd, 0x70, 0xda, 0x47, 0x08, 0x0a, 0x3f, 0x90, 0x29, 0x35, 0xf5, 0x1d, 0x7d, 0xb7, 0x8a,
	0xe5, 0xd9, 0xfe, 0x14, 0x8c, 0x53, 0x4e, 0xb8, 0x3b, 0x88, 0x20, 0x35, 0xd0, 0x4f, 0xd4, 0xbd,
	0x7e, 0x22, 0xa2, 0x33, 0x33, 0x17, 0x45, 0x67, 0xf6, 0x0b, 0xa8, 0x74, 0x3c, 0x1e, 0xe1, 0xea,
	0x90, 0x7f, 0xea, 0x7a, 0x12, 0x99, 0xc7, 0xe2, 0x28, 0x33, 0xe4, 0x42, 0xa2, 0x45, 0x86, 0x5c,
	0x88, 0xcc, 0x19, 0x99, 0x98, 0xf9, 0x28, 0x73, 0x46, 0x26, 0xe8, 0x2e, 0x14, 0x8f, 0xdd, 0x0b,
	0x3a, 0x34, 0x0b, 0x3b, 0xfa, 0x6e, 0x05, 0x47, 0x41, 0xd2, 0x56, 0x31, 0xd3, 0xd6, 0xf7, 0x50,
	0x6d, 0x31, 0x36, 0x59, 0xdb, 0x77, 0x2a, 0x95, 0xcb, 0x4a, 0x65, 0x4a, 0x56, 0x64, 0x49, 0xdb,
	0x01, 0x38, 0x9e, 0x30, 0xc2, 0xff, 0x87, 0x92, 0x1e, 0x29, 0xf5, 0x61, 0x1b, 0x13, 0x6f, 0xc8,
	0xa6, 0xa7, 0xdc, 0x77, 0xbd, 0xd1, 0x7a, 0x41, 0x13, 0xca, 0xed, 0x31, 0xf1, 0x03, 0xca, 0xd5,
	0xec, 0xe2, 0x10, 0x35, 0xa0, 0xf4, 0x84, 0x7a, 0x23, 0x3e, 0x96, 0xba, 0xc5, 0x56, 0xf9, 0xcd,
	0x55, 0x23, 0xef, 0x7a, 0x1c, 0xab, 0xb4, 0x7d, 0x00, 0x75, 0x4c, 0x47, 0xf4, 0x62, 0x53, 0x89,
	0xbb, 0x50, 0x94, 0x38, 0x55, 0x20, 0x0a, 0xec, 0x09, 0x6c, 0xb5, 0x48, 0xe0, 0x0e, 0x0e, 0x43,
	0x3e, 0x5e, 0xcf, 0x45, 0x50, 0xe8, 0x05, 0xd4, 0x57, 0x54, 0x79, 0x46, 0xf7, 0xa1, 0xd2, 0x25,
	0x41, 0xf0, 0x1b, 0xf3, 0x87, 0xb2, 0xb5, 0x2a, 0x4e, 0x62, 0x74, 0x0f, 0x4a, 0xd1, 0xdf, 0xad,
	0x5e, 0x4d, 0x45, 0xf6, 0x29, 0xdc, 0xe9, 0x8a, 0x1d, 0x3b, 0xf4, 0x7d, 0x72, 0xb9, 0xbe, 0xdc,
	0x67, 0x50, 0xfe, 0x6e, 0x42, 0xa7, 0xd4, 0x8b, 0xa6, 0x61, 0xec, 0xa3, 0x3d, 0xb5, 0xd8, 0x92,
	0x2d, 0x89, 0x38, 0x86, 0xd8, 0xbf, 0x40, 0x5d, 0xa6, 0x7f, 0xec, 0xbf, 0xa0, 0x83, 0x77, 0x3c,
	0xda, 0x23, 0xa8, 0x28, 0x4a, 0x60, 0xe6, 0x76, 0xf2, 0x6f, 0x97, 0x6d, 0x15, 0x5e, 0x5e, 0x35,
	0x34, 0x9c, 0x20, 0xed, 0x1e, 0x7c, 0x28, 0x6f, 0x33, 0xe3, 0x5d, 0x5f, 0x62, 0x17, 0x8a, 0xed,
	0xb1, 0x3b, 0x19, 0xbe, 0xa3, 0xed, 0x08, 0x60, 0xff, 0x55, 0x04, 0x48, 0xb3, 0xe8, 0x21, 0x54,
	0xc3, 0xd0, 0x1d, 0xca, 0x40, 0x2a, 0x1a, 0xfb, 0xdb, 0x31, 0x39, 0x31, 0xa3, 0xa3, 0xe1, 0x14,
	0x85, 0x1e, 0x83, 0x11, 0xa4, 0x2e, 0x54, 0x15, 0x3f, 0x88, 0x49, 0x19, 0x83, 0x3a, 0x1a, 0xce,
	0x22, 0xd1, 0x1e, 0x54, 0x5c, 0xe5, 0x49, 0xf9, 0x70, 0xc6, 0x7e, 0x3d, 0x66, 0xc5, 0x5e, 0x75,
	0x34, 0x9c, 0x60, 0x44, 0x6f, 0xfd, 0xd8, 0x57, 0xf2, 0x3d, 0x33, 0xbd, 0x25, 0x86, 0x13, 0xbd,
	0x25, 0x28, 0xf4, 0x08, 0xe0, 0x79, 0xe2, 0x20, 0x69, 0xd2, 0xcc, 0x30, 0x52, 0x6f, 0x39, 0x1a,
	0xce, 0xe0, 0x50, 0x07, 0xb6, 0xfd, 0x55, 0xb7, 0x98, 0x25, 0x49, 0xfe, 0x38, 0x26, 0xdf, 0xb2,
	0x93, 0xa3, 0xe1, 0xdb, 0x2c, 0x74, 0x0c, 0x75, 0x7f, 0xc5, 0x14, 0x66, 0x59, 0x2a, 0x99, 0x89,
	0xd2, 0xca, 0xbd, 0xa3, 0xe1, 0x5b, 0x1c, 0xf4, 0x2d, 0x6c, 0xf5, 0x97, 0xec, 0x61, 0x56, 0xa4,
	0xca, 0xbd, 0x64, 0x00, 0x4b, 0xb7, 0x8e, 0x86, 0x57, 0xf0, 0xe8, 0x6b, 0x00, 0x92, 0x6c, 0xbb,
	0x59, 0x95, 0xec, 0x8f, 0x96, 0xf6, 0x22, 0x35, 0x83, 0x98, 0x47, 0x0a, 0x46, 0x07, 0x60, 0xb0,
	0x74, 0xa7, 0x4d, 0x58, 0xee, 0x7f, 0x75, 0xe7, 0xc5, 0x33, 0x67, 0xe0, 0xe8, 0x04, 0xea, 0xc1,
	0xca, 0xce, 0x9a, 0x86, 0x94, 0xf8, 0x64, 0x49, 0x62, 0x75, 0xb1, 0xc5, 0x1c, 0x56, 0x89, 0xad,
	0x32, 0x14, 0x07, 0xe2, 0x60, 0xff, 0x9b, 0x53, 0x7b, 0x8b, 0x85, 0x02, 0xb2, 0xa1, 0xf6, 0x8c,
	0x4e, 0x67, 0x13, 0xc2, 0x69, 0x97, 0xf0, 0xb1, 0x32, 0xc3, 0x52, 0x4e, 0xfc, 0x18, 0x3c, 0xa5,
	0x7c, 0xcc, 0x86, 0xea, 0xe7, 0x43, 0x45, 0xe8, 0x2b, 0x00, 0x71, 0x2f, 0x0b, 0x04, 0x66, 0x7e,
	0x83, 0x23, 0x33, 0x58, 0x74, 0x00, 0x35, 0x87, 0x92, 0x21, 0xf5, 0x15, 0xb7, 0xb0, 0x81, 0xbb,
	0x84, 0x46, 0xdf, 0x80, 0xf1, 0x53, 0x48, 0xfd, 0x4b, 0x45, 0x2e, 0x6e, 0x20, 0x67, 0xc1, 0xa2,
	0xe7, 0x16, 0x1b, 0xc6, 0xd4, 0xd2, 0xa6, 0x9e, 0x53, 0x2c, 0x7a, 0x08, 0x46, 0x9b, 0x79, 0x9c,
	0x7a, 0xfc, 0xd9, 0xe5, 0x8c, 0x9a, 0xe5, 0x9d, 0xfc, 0x6e, 0xb5, 0x75, 0xe7, 0xcd, 0x55, 0x23,
	0x9b, 0xc6, 0xd9, 0xc0, 0x9e, 0xe7, 0xa0, 0x12, 0x6d, 0x48, 0xb7, 0x23, 0xfe, 0xb9, 0xf4, 0xf0,
	0x13, 0x35, 0x60, 0x71, 0x44, 0x5b, 0x90, 0xeb, 0x1c, 0xa9, 0x99, 0xe6, 0x3a, 0x47, 0xe8, 0x0b,
	0x28, 0xc9, 0x47, 0x79, 0xfb, 0x2c, 0xe5, 0x95, 0xea, 0x4b, 0xe1, 0xde, 0xcb, 0x39, 0x1e, 0x40,
	0xad, 0xcd, 0xd8, 0xb9, 0x4b, 0x15, 0xb7, 0xbc, 0xa9, 0xe7, 0x2c, 0xda, 0x7e, 0x0c, 0xd5, 0x78,
	0xa2, 0xa7, 0xe8, 0x01, 0x14, 0x0e, 0xbb, 0x9d, 0xc0, 0xd4, 0xa5, 0x44, 0x7d, 0xd9, 0x94, 0xdd,
	0x8e, 0x12, 0x90, 0x98, 0xd6, 0xaf, 0xf3, 0x6b, 0x4b, 0x7b, 0x75, 0x6d, 0x69, 0xaf, 0xaf, 0x2d,
	0xfd, 0xf7, 0x85, 0xa5, 0xff, 0xb9, 0xb0, 0xf4, 0x97, 0x0b, 0x4b, 0x9f, 0x2f, 0x2c, 0xfd, 0xef,
	0x85, 0xa5, 0xff, 0xb3, 0xb0, 0xb4, 0xd7, 0x0b, 0x4b, 0xff, 0xe3, 0xc6, 0xd2, 0xe6, 0x37, 0x96,
	0xf6, 0xea, 0xc6, 0xd2, 0x7e, 0x7e, 0x90, 0xf9, 0xf2, 0x22, 0x41, 0x40, 0xb9, 0xc7, 0x38, 0x6d,
	0x9e, 0xbb, 0x9c, 0xfa, 0xa1, 0xe7, 0x51, 0xbf, 0x39, 0x3b, 0x1f, 0x35, 0xa3, 0xb2, 0xfd, 0x92,
	0xfc, 0xfa, 0xfa, 0xf2, 0xbf, 0x00, 0x00, 0x00, 0xff, 0xff, 0xfc, 0x74, 0x63, 0x77, 0xc4, 0x09,
	0x00, 0x00,
}

func (this *UUIDCrumb) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UUIDCrumb)
	if !ok {
		that2, ok := that.(UUIDCrumb)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	return true
}
func (this *StaticCrumb) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StaticCrumb)
	if !ok {
		that2, ok := that.(StaticCrumb)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.K != that1.K {
		return false
	}
	if this.V != that1.V {
		return false
	}
	return true
}
func (this *IntCrumb) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*IntCrumb)
	if !ok {
		that2, ok := that.(IntCrumb)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Min != that1.Min {
		return false
	}
	if this.Max != that1.Max {
		return false
	}
	if this.Val != that1.Val {
		return false
	}
	if this.Fixed != that1.Fixed {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	return true
}
func (this *BoolCrumb) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*BoolCrumb)
	if !ok {
		that2, ok := that.(BoolCrumb)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Fixed != that1.Fixed {
		return false
	}
	if this.Val != that1.Val {
		return false
	}
	return true
}
func (this *FloatCrumb) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FloatCrumb)
	if !ok {
		that2, ok := that.(FloatCrumb)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Fixed != that1.Fixed {
		return false
	}
	if this.Val != that1.Val {
		return false
	}
	return true
}
func (this *RandomStringCrumb) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RandomStringCrumb)
	if !ok {
		that2, ok := that.(RandomStringCrumb)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Charset != that1.Charset {
		return false
	}
	if this.Length != that1.Length {
		return false
	}
	return true
}
func (this *RegexStringCrumb) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RegexStringCrumb)
	if !ok {
		that2, ok := that.(RegexStringCrumb)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Regex != that1.Regex {
		return false
	}
	return true
}
func (this *BasicAuthCrumb) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*BasicAuthCrumb)
	if !ok {
		that2, ok := that.(BasicAuthCrumb)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.User != that1.User {
		return false
	}
	if this.Password != that1.Password {
		return false
	}
	if this.Random != that1.Random {
		return false
	}
	return true
}
func (this *ProtoArrayCrumb) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ProtoArrayCrumb)
	if !ok {
		that2, ok := that.(ProtoArrayCrumb)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if !this.Element.Equal(that1.Element) {
		return false
	}
	return true
}
func (this *ProtoObjectCrumb) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ProtoObjectCrumb)
	if !ok {
		that2, ok := that.(ProtoObjectCrumb)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if len(this.Elements) != len(that1.Elements) {
		return false
	}
	for i := range this.Elements {
		if !this.Elements[i].Equal(&that1.Elements[i]) {
			return false
		}
	}
	return true
}
func (this *ProtoStringCrumbCrumb) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ProtoStringCrumbCrumb)
	if !ok {
		that2, ok := that.(ProtoStringCrumbCrumb)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if !this.Child.Equal(that1.Child) {
		return false
	}
	return true
}
func (this *ProtoCrumb) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ProtoCrumb)
	if !ok {
		that2, ok := that.(ProtoCrumb)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.Crumb == nil {
		if this.Crumb != nil {
			return false
		}
	} else if this.Crumb == nil {
		return false
	} else if !this.Crumb.Equal(that1.Crumb) {
		return false
	}
	return true
}
func (this *ProtoCrumb_UuidCrumb) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ProtoCrumb_UuidCrumb)
	if !ok {
		that2, ok := that.(ProtoCrumb_UuidCrumb)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.UuidCrumb.Equal(that1.UuidCrumb) {
		return false
	}
	return true
}
func (this *ProtoCrumb_StaticCrumb) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ProtoCrumb_StaticCrumb)
	if !ok {
		that2, ok := that.(ProtoCrumb_StaticCrumb)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.StaticCrumb.Equal(that1.StaticCrumb) {
		return false
	}
	return true
}
func (this *ProtoCrumb_IntCrumb) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ProtoCrumb_IntCrumb)
	if !ok {
		that2, ok := that.(ProtoCrumb_IntCrumb)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.IntCrumb.Equal(that1.IntCrumb) {
		return false
	}
	return true
}
func (this *ProtoCrumb_BoolCrumb) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ProtoCrumb_BoolCrumb)
	if !ok {
		that2, ok := that.(ProtoCrumb_BoolCrumb)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.BoolCrumb.Equal(that1.BoolCrumb) {
		return false
	}
	return true
}
func (this *ProtoCrumb_FloatCrumb) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ProtoCrumb_FloatCrumb)
	if !ok {
		that2, ok := that.(ProtoCrumb_FloatCrumb)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.FloatCrumb.Equal(that1.FloatCrumb) {
		return false
	}
	return true
}
func (this *ProtoCrumb_RandomStringCrumb) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ProtoCrumb_RandomStringCrumb)
	if !ok {
		that2, ok := that.(ProtoCrumb_RandomStringCrumb)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.RandomStringCrumb.Equal(that1.RandomStringCrumb) {
		return false
	}
	return true
}
func (this *ProtoCrumb_RegexStringCrumb) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ProtoCrumb_RegexStringCrumb)
	if !ok {
		that2, ok := that.(ProtoCrumb_RegexStringCrumb)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.RegexStringCrumb.Equal(that1.RegexStringCrumb) {
		return false
	}
	return true
}
func (this *ProtoCrumb_BasicAuthCrumb) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ProtoCrumb_BasicAuthCrumb)
	if !ok {
		that2, ok := that.(ProtoCrumb_BasicAuthCrumb)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.BasicAuthCrumb.Equal(that1.BasicAuthCrumb) {
		return false
	}
	return true
}
func (this *ProtoCrumb_ArrayCrumb) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ProtoCrumb_ArrayCrumb)
	if !ok {
		that2, ok := that.(ProtoCrumb_ArrayCrumb)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ArrayCrumb.Equal(that1.ArrayCrumb) {
		return false
	}
	return true
}
func (this *ProtoCrumb_ObjectCrumb) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ProtoCrumb_ObjectCrumb)
	if !ok {
		that2, ok := that.(ProtoCrumb_ObjectCrumb)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ObjectCrumb.Equal(that1.ObjectCrumb) {
		return false
	}
	return true
}
func (this *ProtoCrumb_StringCrumbCrumb) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ProtoCrumb_StringCrumbCrumb)
	if !ok {
		that2, ok := that.(ProtoCrumb_StringCrumbCrumb)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.StringCrumbCrumb.Equal(that1.StringCrumbCrumb) {
		return false
	}
	return true
}
func (this *ProtoRoute) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ProtoRoute)
	if !ok {
		that2, ok := that.(ProtoRoute)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TemplatePath != that1.TemplatePath {
		return false
	}
	if this.Method != that1.Method {
		return false
	}
	if len(this.PathCrumbs) != len(that1.PathCrumbs) {
		return false
	}
	for i := range this.PathCrumbs {
		if !this.PathCrumbs[i].Equal(&that1.PathCrumbs[i]) {
			return false
		}
	}
	if len(this.HeaderCrumbs) != len(that1.HeaderCrumbs) {
		return false
	}
	for i := range this.HeaderCrumbs {
		if !this.HeaderCrumbs[i].Equal(&that1.HeaderCrumbs[i]) {
			return false
		}
	}
	if len(this.QueryCrumbs) != len(that1.QueryCrumbs) {
		return false
	}
	for i := range this.QueryCrumbs {
		if !this.QueryCrumbs[i].Equal(&that1.QueryCrumbs[i]) {
			return false
		}
	}
	if len(this.BodyCrumbs) != len(that1.BodyCrumbs) {
		return false
	}
	for i := range this.BodyCrumbs {
		if !this.BodyCrumbs[i].Equal(&that1.BodyCrumbs[i]) {
			return false
		}
	}
	if len(this.ContentType) != len(that1.ContentType) {
		return false
	}
	for i := range this.ContentType {
		if this.ContentType[i] != that1.ContentType[i] {
			return false
		}
	}
	return true
}
func (this *ProtoAPI) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ProtoAPI)
	if !ok {
		that2, ok := that.(ProtoAPI)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.URL != that1.URL {
		return false
	}
	if this.ID != that1.ID {
		return false
	}
	if len(this.Routes) != len(that1.Routes) {
		return false
	}
	for i := range this.Routes {
		if !this.Routes[i].Equal(&that1.Routes[i]) {
			return false
		}
	}
	if len(this.HeaderCrumbs) != len(that1.HeaderCrumbs) {
		return false
	}
	for i := range this.HeaderCrumbs {
		if !this.HeaderCrumbs[i].Equal(&that1.HeaderCrumbs[i]) {
			return false
		}
	}
	if len(this.QueryCrumbs) != len(that1.QueryCrumbs) {
		return false
	}
	for i := range this.QueryCrumbs {
		if !this.QueryCrumbs[i].Equal(&that1.QueryCrumbs[i]) {
			return false
		}
	}
	if len(this.BodyCrumbs) != len(that1.BodyCrumbs) {
		return false
	}
	for i := range this.BodyCrumbs {
		if !this.BodyCrumbs[i].Equal(&that1.BodyCrumbs[i]) {
			return false
		}
	}
	if len(this.CookieCrumbs) != len(that1.CookieCrumbs) {
		return false
	}
	for i := range this.CookieCrumbs {
		if !this.CookieCrumbs[i].Equal(&that1.CookieCrumbs[i]) {
			return false
		}
	}
	return true
}
func (this *ProtoAPIS) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ProtoAPIS)
	if !ok {
		that2, ok := that.(ProtoAPIS)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.APIs) != len(that1.APIs) {
		return false
	}
	for i := range this.APIs {
		if !this.APIs[i].Equal(&that1.APIs[i]) {
			return false
		}
	}
	return true
}
func (this *UUIDCrumb) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&proute.UUIDCrumb{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *StaticCrumb) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&proute.StaticCrumb{")
	s = append(s, "K: "+fmt.Sprintf("%#v", this.K)+",\n")
	s = append(s, "V: "+fmt.Sprintf("%#v", this.V)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *IntCrumb) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&proute.IntCrumb{")
	s = append(s, "Min: "+fmt.Sprintf("%#v", this.Min)+",\n")
	s = append(s, "Max: "+fmt.Sprintf("%#v", this.Max)+",\n")
	s = append(s, "Val: "+fmt.Sprintf("%#v", this.Val)+",\n")
	s = append(s, "Fixed: "+fmt.Sprintf("%#v", this.Fixed)+",\n")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *BoolCrumb) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&proute.BoolCrumb{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "Fixed: "+fmt.Sprintf("%#v", this.Fixed)+",\n")
	s = append(s, "Val: "+fmt.Sprintf("%#v", this.Val)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *FloatCrumb) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&proute.FloatCrumb{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "Fixed: "+fmt.Sprintf("%#v", this.Fixed)+",\n")
	s = append(s, "Val: "+fmt.Sprintf("%#v", this.Val)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RandomStringCrumb) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&proute.RandomStringCrumb{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "Charset: "+fmt.Sprintf("%#v", this.Charset)+",\n")
	s = append(s, "Length: "+fmt.Sprintf("%#v", this.Length)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RegexStringCrumb) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&proute.RegexStringCrumb{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "Regex: "+fmt.Sprintf("%#v", this.Regex)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *BasicAuthCrumb) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&proute.BasicAuthCrumb{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "User: "+fmt.Sprintf("%#v", this.User)+",\n")
	s = append(s, "Password: "+fmt.Sprintf("%#v", this.Password)+",\n")
	s = append(s, "Random: "+fmt.Sprintf("%#v", this.Random)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ProtoArrayCrumb) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&proute.ProtoArrayCrumb{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	if this.Element != nil {
		s = append(s, "Element: "+fmt.Sprintf("%#v", this.Element)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ProtoObjectCrumb) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&proute.ProtoObjectCrumb{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	if this.Elements != nil {
		vs := make([]ProtoCrumb, len(this.Elements))
		for i := range vs {
			vs[i] = this.Elements[i]
		}
		s = append(s, "Elements: "+fmt.Sprintf("%#v", vs)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ProtoStringCrumbCrumb) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&proute.ProtoStringCrumbCrumb{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	if this.Child != nil {
		s = append(s, "Child: "+fmt.Sprintf("%#v", this.Child)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ProtoCrumb) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 15)
	s = append(s, "&proute.ProtoCrumb{")
	if this.Crumb != nil {
		s = append(s, "Crumb: "+fmt.Sprintf("%#v", this.Crumb)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ProtoCrumb_UuidCrumb) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&proute.ProtoCrumb_UuidCrumb{` +
		`UuidCrumb:` + fmt.Sprintf("%#v", this.UuidCrumb) + `}`}, ", ")
	return s
}
func (this *ProtoCrumb_StaticCrumb) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&proute.ProtoCrumb_StaticCrumb{` +
		`StaticCrumb:` + fmt.Sprintf("%#v", this.StaticCrumb) + `}`}, ", ")
	return s
}
func (this *ProtoCrumb_IntCrumb) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&proute.ProtoCrumb_IntCrumb{` +
		`IntCrumb:` + fmt.Sprintf("%#v", this.IntCrumb) + `}`}, ", ")
	return s
}
func (this *ProtoCrumb_BoolCrumb) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&proute.ProtoCrumb_BoolCrumb{` +
		`BoolCrumb:` + fmt.Sprintf("%#v", this.BoolCrumb) + `}`}, ", ")
	return s
}
func (this *ProtoCrumb_FloatCrumb) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&proute.ProtoCrumb_FloatCrumb{` +
		`FloatCrumb:` + fmt.Sprintf("%#v", this.FloatCrumb) + `}`}, ", ")
	return s
}
func (this *ProtoCrumb_RandomStringCrumb) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&proute.ProtoCrumb_RandomStringCrumb{` +
		`RandomStringCrumb:` + fmt.Sprintf("%#v", this.RandomStringCrumb) + `}`}, ", ")
	return s
}
func (this *ProtoCrumb_RegexStringCrumb) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&proute.ProtoCrumb_RegexStringCrumb{` +
		`RegexStringCrumb:` + fmt.Sprintf("%#v", this.RegexStringCrumb) + `}`}, ", ")
	return s
}
func (this *ProtoCrumb_BasicAuthCrumb) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&proute.ProtoCrumb_BasicAuthCrumb{` +
		`BasicAuthCrumb:` + fmt.Sprintf("%#v", this.BasicAuthCrumb) + `}`}, ", ")
	return s
}
func (this *ProtoCrumb_ArrayCrumb) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&proute.ProtoCrumb_ArrayCrumb{` +
		`ArrayCrumb:` + fmt.Sprintf("%#v", this.ArrayCrumb) + `}`}, ", ")
	return s
}
func (this *ProtoCrumb_ObjectCrumb) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&proute.ProtoCrumb_ObjectCrumb{` +
		`ObjectCrumb:` + fmt.Sprintf("%#v", this.ObjectCrumb) + `}`}, ", ")
	return s
}
func (this *ProtoCrumb_StringCrumbCrumb) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&proute.ProtoCrumb_StringCrumbCrumb{` +
		`StringCrumbCrumb:` + fmt.Sprintf("%#v", this.StringCrumbCrumb) + `}`}, ", ")
	return s
}
func (this *ProtoRoute) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&proute.ProtoRoute{")
	s = append(s, "TemplatePath: "+fmt.Sprintf("%#v", this.TemplatePath)+",\n")
	s = append(s, "Method: "+fmt.Sprintf("%#v", this.Method)+",\n")
	if this.PathCrumbs != nil {
		vs := make([]ProtoCrumb, len(this.PathCrumbs))
		for i := range vs {
			vs[i] = this.PathCrumbs[i]
		}
		s = append(s, "PathCrumbs: "+fmt.Sprintf("%#v", vs)+",\n")
	}
	if this.HeaderCrumbs != nil {
		vs := make([]ProtoCrumb, len(this.HeaderCrumbs))
		for i := range vs {
			vs[i] = this.HeaderCrumbs[i]
		}
		s = append(s, "HeaderCrumbs: "+fmt.Sprintf("%#v", vs)+",\n")
	}
	if this.QueryCrumbs != nil {
		vs := make([]ProtoCrumb, len(this.QueryCrumbs))
		for i := range vs {
			vs[i] = this.QueryCrumbs[i]
		}
		s = append(s, "QueryCrumbs: "+fmt.Sprintf("%#v", vs)+",\n")
	}
	if this.BodyCrumbs != nil {
		vs := make([]ProtoCrumb, len(this.BodyCrumbs))
		for i := range vs {
			vs[i] = this.BodyCrumbs[i]
		}
		s = append(s, "BodyCrumbs: "+fmt.Sprintf("%#v", vs)+",\n")
	}
	s = append(s, "ContentType: "+fmt.Sprintf("%#v", this.ContentType)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ProtoAPI) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&proute.ProtoAPI{")
	s = append(s, "URL: "+fmt.Sprintf("%#v", this.URL)+",\n")
	s = append(s, "ID: "+fmt.Sprintf("%#v", this.ID)+",\n")
	if this.Routes != nil {
		vs := make([]ProtoRoute, len(this.Routes))
		for i := range vs {
			vs[i] = this.Routes[i]
		}
		s = append(s, "Routes: "+fmt.Sprintf("%#v", vs)+",\n")
	}
	if this.HeaderCrumbs != nil {
		vs := make([]ProtoCrumb, len(this.HeaderCrumbs))
		for i := range vs {
			vs[i] = this.HeaderCrumbs[i]
		}
		s = append(s, "HeaderCrumbs: "+fmt.Sprintf("%#v", vs)+",\n")
	}
	if this.QueryCrumbs != nil {
		vs := make([]ProtoCrumb, len(this.QueryCrumbs))
		for i := range vs {
			vs[i] = this.QueryCrumbs[i]
		}
		s = append(s, "QueryCrumbs: "+fmt.Sprintf("%#v", vs)+",\n")
	}
	if this.BodyCrumbs != nil {
		vs := make([]ProtoCrumb, len(this.BodyCrumbs))
		for i := range vs {
			vs[i] = this.BodyCrumbs[i]
		}
		s = append(s, "BodyCrumbs: "+fmt.Sprintf("%#v", vs)+",\n")
	}
	if this.CookieCrumbs != nil {
		vs := make([]ProtoCrumb, len(this.CookieCrumbs))
		for i := range vs {
			vs[i] = this.CookieCrumbs[i]
		}
		s = append(s, "CookieCrumbs: "+fmt.Sprintf("%#v", vs)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ProtoAPIS) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&proute.ProtoAPIS{")
	if this.APIs != nil {
		vs := make([]ProtoAPI, len(this.APIs))
		for i := range vs {
			vs[i] = this.APIs[i]
		}
		s = append(s, "APIs: "+fmt.Sprintf("%#v", vs)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringProute(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *UUIDCrumb) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UUIDCrumb) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UUIDCrumb) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintProute(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StaticCrumb) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StaticCrumb) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StaticCrumb) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.V) > 0 {
		i -= len(m.V)
		copy(dAtA[i:], m.V)
		i = encodeVarintProute(dAtA, i, uint64(len(m.V)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.K) > 0 {
		i -= len(m.K)
		copy(dAtA[i:], m.K)
		i = encodeVarintProute(dAtA, i, uint64(len(m.K)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *IntCrumb) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IntCrumb) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IntCrumb) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintProute(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Fixed {
		i--
		if m.Fixed {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.Val != 0 {
		i = encodeVarintProute(dAtA, i, uint64(m.Val))
		i--
		dAtA[i] = 0x18
	}
	if m.Max != 0 {
		i = encodeVarintProute(dAtA, i, uint64(m.Max))
		i--
		dAtA[i] = 0x10
	}
	if m.Min != 0 {
		i = encodeVarintProute(dAtA, i, uint64(m.Min))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BoolCrumb) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BoolCrumb) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BoolCrumb) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Val {
		i--
		if m.Val {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.Fixed {
		i--
		if m.Fixed {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintProute(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FloatCrumb) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FloatCrumb) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FloatCrumb) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Val != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Val))))
		i--
		dAtA[i] = 0x19
	}
	if m.Fixed {
		i--
		if m.Fixed {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintProute(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RandomStringCrumb) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RandomStringCrumb) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RandomStringCrumb) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Length != 0 {
		i = encodeVarintProute(dAtA, i, uint64(m.Length))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Charset) > 0 {
		i -= len(m.Charset)
		copy(dAtA[i:], m.Charset)
		i = encodeVarintProute(dAtA, i, uint64(len(m.Charset)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintProute(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RegexStringCrumb) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RegexStringCrumb) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RegexStringCrumb) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Regex) > 0 {
		i -= len(m.Regex)
		copy(dAtA[i:], m.Regex)
		i = encodeVarintProute(dAtA, i, uint64(len(m.Regex)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintProute(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BasicAuthCrumb) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BasicAuthCrumb) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BasicAuthCrumb) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Random {
		i--
		if m.Random {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if len(m.Password) > 0 {
		i -= len(m.Password)
		copy(dAtA[i:], m.Password)
		i = encodeVarintProute(dAtA, i, uint64(len(m.Password)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.User) > 0 {
		i -= len(m.User)
		copy(dAtA[i:], m.User)
		i = encodeVarintProute(dAtA, i, uint64(len(m.User)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintProute(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ProtoArrayCrumb) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProtoArrayCrumb) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProtoArrayCrumb) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Element != nil {
		{
			size, err := m.Element.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProute(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintProute(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ProtoObjectCrumb) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProtoObjectCrumb) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProtoObjectCrumb) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Elements) > 0 {
		for iNdEx := len(m.Elements) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Elements[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintProute(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintProute(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ProtoStringCrumbCrumb) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProtoStringCrumbCrumb) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProtoStringCrumbCrumb) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Child != nil {
		{
			size, err := m.Child.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProute(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintProute(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ProtoCrumb) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProtoCrumb) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProtoCrumb) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Crumb != nil {
		{
			size := m.Crumb.Size()
			i -= size
			if _, err := m.Crumb.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *ProtoCrumb_UuidCrumb) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProtoCrumb_UuidCrumb) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.UuidCrumb != nil {
		{
			size, err := m.UuidCrumb.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProute(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *ProtoCrumb_StaticCrumb) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProtoCrumb_StaticCrumb) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.StaticCrumb != nil {
		{
			size, err := m.StaticCrumb.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProute(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *ProtoCrumb_IntCrumb) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProtoCrumb_IntCrumb) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.IntCrumb != nil {
		{
			size, err := m.IntCrumb.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProute(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *ProtoCrumb_BoolCrumb) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProtoCrumb_BoolCrumb) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.BoolCrumb != nil {
		{
			size, err := m.BoolCrumb.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProute(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *ProtoCrumb_FloatCrumb) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProtoCrumb_FloatCrumb) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.FloatCrumb != nil {
		{
			size, err := m.FloatCrumb.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProute(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *ProtoCrumb_RandomStringCrumb) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProtoCrumb_RandomStringCrumb) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.RandomStringCrumb != nil {
		{
			size, err := m.RandomStringCrumb.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProute(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *ProtoCrumb_RegexStringCrumb) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProtoCrumb_RegexStringCrumb) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.RegexStringCrumb != nil {
		{
			size, err := m.RegexStringCrumb.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProute(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}
func (m *ProtoCrumb_BasicAuthCrumb) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProtoCrumb_BasicAuthCrumb) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.BasicAuthCrumb != nil {
		{
			size, err := m.BasicAuthCrumb.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProute(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	return len(dAtA) - i, nil
}
func (m *ProtoCrumb_ArrayCrumb) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProtoCrumb_ArrayCrumb) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ArrayCrumb != nil {
		{
			size, err := m.ArrayCrumb.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProute(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	return len(dAtA) - i, nil
}
func (m *ProtoCrumb_ObjectCrumb) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProtoCrumb_ObjectCrumb) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ObjectCrumb != nil {
		{
			size, err := m.ObjectCrumb.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProute(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	return len(dAtA) - i, nil
}
func (m *ProtoCrumb_StringCrumbCrumb) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProtoCrumb_StringCrumbCrumb) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.StringCrumbCrumb != nil {
		{
			size, err := m.StringCrumbCrumb.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProute(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	return len(dAtA) - i, nil
}
func (m *ProtoRoute) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProtoRoute) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProtoRoute) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ContentType) > 0 {
		for iNdEx := len(m.ContentType) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ContentType[iNdEx])
			copy(dAtA[i:], m.ContentType[iNdEx])
			i = encodeVarintProute(dAtA, i, uint64(len(m.ContentType[iNdEx])))
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.BodyCrumbs) > 0 {
		for iNdEx := len(m.BodyCrumbs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.BodyCrumbs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintProute(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.QueryCrumbs) > 0 {
		for iNdEx := len(m.QueryCrumbs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.QueryCrumbs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintProute(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.HeaderCrumbs) > 0 {
		for iNdEx := len(m.HeaderCrumbs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.HeaderCrumbs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintProute(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.PathCrumbs) > 0 {
		for iNdEx := len(m.PathCrumbs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PathCrumbs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintProute(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Method) > 0 {
		i -= len(m.Method)
		copy(dAtA[i:], m.Method)
		i = encodeVarintProute(dAtA, i, uint64(len(m.Method)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.TemplatePath) > 0 {
		i -= len(m.TemplatePath)
		copy(dAtA[i:], m.TemplatePath)
		i = encodeVarintProute(dAtA, i, uint64(len(m.TemplatePath)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ProtoAPI) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProtoAPI) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProtoAPI) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CookieCrumbs) > 0 {
		for iNdEx := len(m.CookieCrumbs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CookieCrumbs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintProute(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.BodyCrumbs) > 0 {
		for iNdEx := len(m.BodyCrumbs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.BodyCrumbs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintProute(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.QueryCrumbs) > 0 {
		for iNdEx := len(m.QueryCrumbs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.QueryCrumbs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintProute(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.HeaderCrumbs) > 0 {
		for iNdEx := len(m.HeaderCrumbs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.HeaderCrumbs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintProute(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Routes) > 0 {
		for iNdEx := len(m.Routes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Routes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintProute(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.ID) > 0 {
		i -= len(m.ID)
		copy(dAtA[i:], m.ID)
		i = encodeVarintProute(dAtA, i, uint64(len(m.ID)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.URL) > 0 {
		i -= len(m.URL)
		copy(dAtA[i:], m.URL)
		i = encodeVarintProute(dAtA, i, uint64(len(m.URL)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ProtoAPIS) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProtoAPIS) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProtoAPIS) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.APIs) > 0 {
		for iNdEx := len(m.APIs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.APIs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintProute(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintProute(dAtA []byte, offset int, v uint64) int {
	offset -= sovProute(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *UUIDCrumb) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovProute(uint64(l))
	}
	return n
}

func (m *StaticCrumb) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.K)
	if l > 0 {
		n += 1 + l + sovProute(uint64(l))
	}
	l = len(m.V)
	if l > 0 {
		n += 1 + l + sovProute(uint64(l))
	}
	return n
}

func (m *IntCrumb) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Min != 0 {
		n += 1 + sovProute(uint64(m.Min))
	}
	if m.Max != 0 {
		n += 1 + sovProute(uint64(m.Max))
	}
	if m.Val != 0 {
		n += 1 + sovProute(uint64(m.Val))
	}
	if m.Fixed {
		n += 2
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovProute(uint64(l))
	}
	return n
}

func (m *BoolCrumb) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovProute(uint64(l))
	}
	if m.Fixed {
		n += 2
	}
	if m.Val {
		n += 2
	}
	return n
}

func (m *FloatCrumb) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovProute(uint64(l))
	}
	if m.Fixed {
		n += 2
	}
	if m.Val != 0 {
		n += 9
	}
	return n
}

func (m *RandomStringCrumb) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovProute(uint64(l))
	}
	l = len(m.Charset)
	if l > 0 {
		n += 1 + l + sovProute(uint64(l))
	}
	if m.Length != 0 {
		n += 1 + sovProute(uint64(m.Length))
	}
	return n
}

func (m *RegexStringCrumb) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovProute(uint64(l))
	}
	l = len(m.Regex)
	if l > 0 {
		n += 1 + l + sovProute(uint64(l))
	}
	return n
}

func (m *BasicAuthCrumb) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovProute(uint64(l))
	}
	l = len(m.User)
	if l > 0 {
		n += 1 + l + sovProute(uint64(l))
	}
	l = len(m.Password)
	if l > 0 {
		n += 1 + l + sovProute(uint64(l))
	}
	if m.Random {
		n += 2
	}
	return n
}

func (m *ProtoArrayCrumb) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovProute(uint64(l))
	}
	if m.Element != nil {
		l = m.Element.Size()
		n += 1 + l + sovProute(uint64(l))
	}
	return n
}

func (m *ProtoObjectCrumb) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovProute(uint64(l))
	}
	if len(m.Elements) > 0 {
		for _, e := range m.Elements {
			l = e.Size()
			n += 1 + l + sovProute(uint64(l))
		}
	}
	return n
}

func (m *ProtoStringCrumbCrumb) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovProute(uint64(l))
	}
	if m.Child != nil {
		l = m.Child.Size()
		n += 1 + l + sovProute(uint64(l))
	}
	return n
}

func (m *ProtoCrumb) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Crumb != nil {
		n += m.Crumb.Size()
	}
	return n
}

func (m *ProtoCrumb_UuidCrumb) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UuidCrumb != nil {
		l = m.UuidCrumb.Size()
		n += 1 + l + sovProute(uint64(l))
	}
	return n
}
func (m *ProtoCrumb_StaticCrumb) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StaticCrumb != nil {
		l = m.StaticCrumb.Size()
		n += 1 + l + sovProute(uint64(l))
	}
	return n
}
func (m *ProtoCrumb_IntCrumb) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IntCrumb != nil {
		l = m.IntCrumb.Size()
		n += 1 + l + sovProute(uint64(l))
	}
	return n
}
func (m *ProtoCrumb_BoolCrumb) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BoolCrumb != nil {
		l = m.BoolCrumb.Size()
		n += 1 + l + sovProute(uint64(l))
	}
	return n
}
func (m *ProtoCrumb_FloatCrumb) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.FloatCrumb != nil {
		l = m.FloatCrumb.Size()
		n += 1 + l + sovProute(uint64(l))
	}
	return n
}
func (m *ProtoCrumb_RandomStringCrumb) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RandomStringCrumb != nil {
		l = m.RandomStringCrumb.Size()
		n += 1 + l + sovProute(uint64(l))
	}
	return n
}
func (m *ProtoCrumb_RegexStringCrumb) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RegexStringCrumb != nil {
		l = m.RegexStringCrumb.Size()
		n += 1 + l + sovProute(uint64(l))
	}
	return n
}
func (m *ProtoCrumb_BasicAuthCrumb) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BasicAuthCrumb != nil {
		l = m.BasicAuthCrumb.Size()
		n += 1 + l + sovProute(uint64(l))
	}
	return n
}
func (m *ProtoCrumb_ArrayCrumb) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ArrayCrumb != nil {
		l = m.ArrayCrumb.Size()
		n += 1 + l + sovProute(uint64(l))
	}
	return n
}
func (m *ProtoCrumb_ObjectCrumb) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ObjectCrumb != nil {
		l = m.ObjectCrumb.Size()
		n += 1 + l + sovProute(uint64(l))
	}
	return n
}
func (m *ProtoCrumb_StringCrumbCrumb) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StringCrumbCrumb != nil {
		l = m.StringCrumbCrumb.Size()
		n += 1 + l + sovProute(uint64(l))
	}
	return n
}
func (m *ProtoRoute) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TemplatePath)
	if l > 0 {
		n += 1 + l + sovProute(uint64(l))
	}
	l = len(m.Method)
	if l > 0 {
		n += 1 + l + sovProute(uint64(l))
	}
	if len(m.PathCrumbs) > 0 {
		for _, e := range m.PathCrumbs {
			l = e.Size()
			n += 1 + l + sovProute(uint64(l))
		}
	}
	if len(m.HeaderCrumbs) > 0 {
		for _, e := range m.HeaderCrumbs {
			l = e.Size()
			n += 1 + l + sovProute(uint64(l))
		}
	}
	if len(m.QueryCrumbs) > 0 {
		for _, e := range m.QueryCrumbs {
			l = e.Size()
			n += 1 + l + sovProute(uint64(l))
		}
	}
	if len(m.BodyCrumbs) > 0 {
		for _, e := range m.BodyCrumbs {
			l = e.Size()
			n += 1 + l + sovProute(uint64(l))
		}
	}
	if len(m.ContentType) > 0 {
		for _, s := range m.ContentType {
			l = len(s)
			n += 1 + l + sovProute(uint64(l))
		}
	}
	return n
}

func (m *ProtoAPI) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.URL)
	if l > 0 {
		n += 1 + l + sovProute(uint64(l))
	}
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovProute(uint64(l))
	}
	if len(m.Routes) > 0 {
		for _, e := range m.Routes {
			l = e.Size()
			n += 1 + l + sovProute(uint64(l))
		}
	}
	if len(m.HeaderCrumbs) > 0 {
		for _, e := range m.HeaderCrumbs {
			l = e.Size()
			n += 1 + l + sovProute(uint64(l))
		}
	}
	if len(m.QueryCrumbs) > 0 {
		for _, e := range m.QueryCrumbs {
			l = e.Size()
			n += 1 + l + sovProute(uint64(l))
		}
	}
	if len(m.BodyCrumbs) > 0 {
		for _, e := range m.BodyCrumbs {
			l = e.Size()
			n += 1 + l + sovProute(uint64(l))
		}
	}
	if len(m.CookieCrumbs) > 0 {
		for _, e := range m.CookieCrumbs {
			l = e.Size()
			n += 1 + l + sovProute(uint64(l))
		}
	}
	return n
}

func (m *ProtoAPIS) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.APIs) > 0 {
		for _, e := range m.APIs {
			l = e.Size()
			n += 1 + l + sovProute(uint64(l))
		}
	}
	return n
}

func sovProute(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozProute(x uint64) (n int) {
	return sovProute(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *UUIDCrumb) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&UUIDCrumb{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StaticCrumb) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&StaticCrumb{`,
		`K:` + fmt.Sprintf("%v", this.K) + `,`,
		`V:` + fmt.Sprintf("%v", this.V) + `,`,
		`}`,
	}, "")
	return s
}
func (this *IntCrumb) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&IntCrumb{`,
		`Min:` + fmt.Sprintf("%v", this.Min) + `,`,
		`Max:` + fmt.Sprintf("%v", this.Max) + `,`,
		`Val:` + fmt.Sprintf("%v", this.Val) + `,`,
		`Fixed:` + fmt.Sprintf("%v", this.Fixed) + `,`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`}`,
	}, "")
	return s
}
func (this *BoolCrumb) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&BoolCrumb{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Fixed:` + fmt.Sprintf("%v", this.Fixed) + `,`,
		`Val:` + fmt.Sprintf("%v", this.Val) + `,`,
		`}`,
	}, "")
	return s
}
func (this *FloatCrumb) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&FloatCrumb{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Fixed:` + fmt.Sprintf("%v", this.Fixed) + `,`,
		`Val:` + fmt.Sprintf("%v", this.Val) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RandomStringCrumb) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RandomStringCrumb{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Charset:` + fmt.Sprintf("%v", this.Charset) + `,`,
		`Length:` + fmt.Sprintf("%v", this.Length) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RegexStringCrumb) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RegexStringCrumb{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Regex:` + fmt.Sprintf("%v", this.Regex) + `,`,
		`}`,
	}, "")
	return s
}
func (this *BasicAuthCrumb) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&BasicAuthCrumb{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`User:` + fmt.Sprintf("%v", this.User) + `,`,
		`Password:` + fmt.Sprintf("%v", this.Password) + `,`,
		`Random:` + fmt.Sprintf("%v", this.Random) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ProtoArrayCrumb) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ProtoArrayCrumb{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Element:` + strings.Replace(this.Element.String(), "ProtoCrumb", "ProtoCrumb", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ProtoObjectCrumb) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForElements := "[]ProtoCrumb{"
	for _, f := range this.Elements {
		repeatedStringForElements += strings.Replace(strings.Replace(f.String(), "ProtoCrumb", "ProtoCrumb", 1), `&`, ``, 1) + ","
	}
	repeatedStringForElements += "}"
	s := strings.Join([]string{`&ProtoObjectCrumb{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Elements:` + repeatedStringForElements + `,`,
		`}`,
	}, "")
	return s
}
func (this *ProtoStringCrumbCrumb) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ProtoStringCrumbCrumb{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Child:` + strings.Replace(this.Child.String(), "ProtoCrumb", "ProtoCrumb", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ProtoCrumb) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ProtoCrumb{`,
		`Crumb:` + fmt.Sprintf("%v", this.Crumb) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ProtoCrumb_UuidCrumb) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ProtoCrumb_UuidCrumb{`,
		`UuidCrumb:` + strings.Replace(fmt.Sprintf("%v", this.UuidCrumb), "UUIDCrumb", "UUIDCrumb", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ProtoCrumb_StaticCrumb) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ProtoCrumb_StaticCrumb{`,
		`StaticCrumb:` + strings.Replace(fmt.Sprintf("%v", this.StaticCrumb), "StaticCrumb", "StaticCrumb", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ProtoCrumb_IntCrumb) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ProtoCrumb_IntCrumb{`,
		`IntCrumb:` + strings.Replace(fmt.Sprintf("%v", this.IntCrumb), "IntCrumb", "IntCrumb", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ProtoCrumb_BoolCrumb) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ProtoCrumb_BoolCrumb{`,
		`BoolCrumb:` + strings.Replace(fmt.Sprintf("%v", this.BoolCrumb), "BoolCrumb", "BoolCrumb", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ProtoCrumb_FloatCrumb) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ProtoCrumb_FloatCrumb{`,
		`FloatCrumb:` + strings.Replace(fmt.Sprintf("%v", this.FloatCrumb), "FloatCrumb", "FloatCrumb", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ProtoCrumb_RandomStringCrumb) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ProtoCrumb_RandomStringCrumb{`,
		`RandomStringCrumb:` + strings.Replace(fmt.Sprintf("%v", this.RandomStringCrumb), "RandomStringCrumb", "RandomStringCrumb", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ProtoCrumb_RegexStringCrumb) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ProtoCrumb_RegexStringCrumb{`,
		`RegexStringCrumb:` + strings.Replace(fmt.Sprintf("%v", this.RegexStringCrumb), "RegexStringCrumb", "RegexStringCrumb", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ProtoCrumb_BasicAuthCrumb) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ProtoCrumb_BasicAuthCrumb{`,
		`BasicAuthCrumb:` + strings.Replace(fmt.Sprintf("%v", this.BasicAuthCrumb), "BasicAuthCrumb", "BasicAuthCrumb", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ProtoCrumb_ArrayCrumb) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ProtoCrumb_ArrayCrumb{`,
		`ArrayCrumb:` + strings.Replace(fmt.Sprintf("%v", this.ArrayCrumb), "ProtoArrayCrumb", "ProtoArrayCrumb", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ProtoCrumb_ObjectCrumb) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ProtoCrumb_ObjectCrumb{`,
		`ObjectCrumb:` + strings.Replace(fmt.Sprintf("%v", this.ObjectCrumb), "ProtoObjectCrumb", "ProtoObjectCrumb", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ProtoCrumb_StringCrumbCrumb) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ProtoCrumb_StringCrumbCrumb{`,
		`StringCrumbCrumb:` + strings.Replace(fmt.Sprintf("%v", this.StringCrumbCrumb), "ProtoStringCrumbCrumb", "ProtoStringCrumbCrumb", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ProtoRoute) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForPathCrumbs := "[]ProtoCrumb{"
	for _, f := range this.PathCrumbs {
		repeatedStringForPathCrumbs += strings.Replace(strings.Replace(f.String(), "ProtoCrumb", "ProtoCrumb", 1), `&`, ``, 1) + ","
	}
	repeatedStringForPathCrumbs += "}"
	repeatedStringForHeaderCrumbs := "[]ProtoCrumb{"
	for _, f := range this.HeaderCrumbs {
		repeatedStringForHeaderCrumbs += strings.Replace(strings.Replace(f.String(), "ProtoCrumb", "ProtoCrumb", 1), `&`, ``, 1) + ","
	}
	repeatedStringForHeaderCrumbs += "}"
	repeatedStringForQueryCrumbs := "[]ProtoCrumb{"
	for _, f := range this.QueryCrumbs {
		repeatedStringForQueryCrumbs += strings.Replace(strings.Replace(f.String(), "ProtoCrumb", "ProtoCrumb", 1), `&`, ``, 1) + ","
	}
	repeatedStringForQueryCrumbs += "}"
	repeatedStringForBodyCrumbs := "[]ProtoCrumb{"
	for _, f := range this.BodyCrumbs {
		repeatedStringForBodyCrumbs += strings.Replace(strings.Replace(f.String(), "ProtoCrumb", "ProtoCrumb", 1), `&`, ``, 1) + ","
	}
	repeatedStringForBodyCrumbs += "}"
	s := strings.Join([]string{`&ProtoRoute{`,
		`TemplatePath:` + fmt.Sprintf("%v", this.TemplatePath) + `,`,
		`Method:` + fmt.Sprintf("%v", this.Method) + `,`,
		`PathCrumbs:` + repeatedStringForPathCrumbs + `,`,
		`HeaderCrumbs:` + repeatedStringForHeaderCrumbs + `,`,
		`QueryCrumbs:` + repeatedStringForQueryCrumbs + `,`,
		`BodyCrumbs:` + repeatedStringForBodyCrumbs + `,`,
		`ContentType:` + fmt.Sprintf("%v", this.ContentType) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ProtoAPI) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForRoutes := "[]ProtoRoute{"
	for _, f := range this.Routes {
		repeatedStringForRoutes += strings.Replace(strings.Replace(f.String(), "ProtoRoute", "ProtoRoute", 1), `&`, ``, 1) + ","
	}
	repeatedStringForRoutes += "}"
	repeatedStringForHeaderCrumbs := "[]ProtoCrumb{"
	for _, f := range this.HeaderCrumbs {
		repeatedStringForHeaderCrumbs += strings.Replace(strings.Replace(f.String(), "ProtoCrumb", "ProtoCrumb", 1), `&`, ``, 1) + ","
	}
	repeatedStringForHeaderCrumbs += "}"
	repeatedStringForQueryCrumbs := "[]ProtoCrumb{"
	for _, f := range this.QueryCrumbs {
		repeatedStringForQueryCrumbs += strings.Replace(strings.Replace(f.String(), "ProtoCrumb", "ProtoCrumb", 1), `&`, ``, 1) + ","
	}
	repeatedStringForQueryCrumbs += "}"
	repeatedStringForBodyCrumbs := "[]ProtoCrumb{"
	for _, f := range this.BodyCrumbs {
		repeatedStringForBodyCrumbs += strings.Replace(strings.Replace(f.String(), "ProtoCrumb", "ProtoCrumb", 1), `&`, ``, 1) + ","
	}
	repeatedStringForBodyCrumbs += "}"
	repeatedStringForCookieCrumbs := "[]ProtoCrumb{"
	for _, f := range this.CookieCrumbs {
		repeatedStringForCookieCrumbs += strings.Replace(strings.Replace(f.String(), "ProtoCrumb", "ProtoCrumb", 1), `&`, ``, 1) + ","
	}
	repeatedStringForCookieCrumbs += "}"
	s := strings.Join([]string{`&ProtoAPI{`,
		`URL:` + fmt.Sprintf("%v", this.URL) + `,`,
		`ID:` + fmt.Sprintf("%v", this.ID) + `,`,
		`Routes:` + repeatedStringForRoutes + `,`,
		`HeaderCrumbs:` + repeatedStringForHeaderCrumbs + `,`,
		`QueryCrumbs:` + repeatedStringForQueryCrumbs + `,`,
		`BodyCrumbs:` + repeatedStringForBodyCrumbs + `,`,
		`CookieCrumbs:` + repeatedStringForCookieCrumbs + `,`,
		`}`,
	}, "")
	return s
}
func (this *ProtoAPIS) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForAPIs := "[]ProtoAPI{"
	for _, f := range this.APIs {
		repeatedStringForAPIs += strings.Replace(strings.Replace(f.String(), "ProtoAPI", "ProtoAPI", 1), `&`, ``, 1) + ","
	}
	repeatedStringForAPIs += "}"
	s := strings.Join([]string{`&ProtoAPIS{`,
		`APIs:` + repeatedStringForAPIs + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringProute(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *UUIDCrumb) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UUIDCrumb: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UUIDCrumb: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProute
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StaticCrumb) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StaticCrumb: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StaticCrumb: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field K", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProute
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.K = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field V", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProute
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.V = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IntCrumb) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IntCrumb: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IntCrumb: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Min", wireType)
			}
			m.Min = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Min |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Max", wireType)
			}
			m.Max = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Max |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Val", wireType)
			}
			m.Val = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Val |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fixed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Fixed = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProute
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BoolCrumb) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BoolCrumb: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BoolCrumb: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProute
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fixed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Fixed = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Val", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Val = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipProute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FloatCrumb) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FloatCrumb: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FloatCrumb: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProute
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fixed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Fixed = bool(v != 0)
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Val", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Val = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipProute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RandomStringCrumb) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RandomStringCrumb: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RandomStringCrumb: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProute
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Charset", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProute
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Charset = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Length", wireType)
			}
			m.Length = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Length |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RegexStringCrumb) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RegexStringCrumb: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RegexStringCrumb: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProute
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Regex", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProute
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Regex = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BasicAuthCrumb) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BasicAuthCrumb: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BasicAuthCrumb: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProute
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProute
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.User = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Password", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProute
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Password = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Random", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Random = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipProute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProtoArrayCrumb) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProtoArrayCrumb: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProtoArrayCrumb: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProute
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Element", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProute
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Element == nil {
				m.Element = &ProtoCrumb{}
			}
			if err := m.Element.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProtoObjectCrumb) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProtoObjectCrumb: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProtoObjectCrumb: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProute
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Elements", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProute
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Elements = append(m.Elements, ProtoCrumb{})
			if err := m.Elements[len(m.Elements)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProtoStringCrumbCrumb) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProtoStringCrumbCrumb: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProtoStringCrumbCrumb: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProute
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Child", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProute
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Child == nil {
				m.Child = &ProtoCrumb{}
			}
			if err := m.Child.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProtoCrumb) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProtoCrumb: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProtoCrumb: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UuidCrumb", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProute
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &UUIDCrumb{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Crumb = &ProtoCrumb_UuidCrumb{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StaticCrumb", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProute
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &StaticCrumb{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Crumb = &ProtoCrumb_StaticCrumb{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IntCrumb", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProute
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &IntCrumb{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Crumb = &ProtoCrumb_IntCrumb{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BoolCrumb", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProute
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &BoolCrumb{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Crumb = &ProtoCrumb_BoolCrumb{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FloatCrumb", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProute
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &FloatCrumb{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Crumb = &ProtoCrumb_FloatCrumb{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RandomStringCrumb", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProute
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RandomStringCrumb{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Crumb = &ProtoCrumb_RandomStringCrumb{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegexStringCrumb", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProute
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RegexStringCrumb{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Crumb = &ProtoCrumb_RegexStringCrumb{v}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BasicAuthCrumb", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProute
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &BasicAuthCrumb{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Crumb = &ProtoCrumb_BasicAuthCrumb{v}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArrayCrumb", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProute
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ProtoArrayCrumb{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Crumb = &ProtoCrumb_ArrayCrumb{v}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectCrumb", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProute
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ProtoObjectCrumb{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Crumb = &ProtoCrumb_ObjectCrumb{v}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StringCrumbCrumb", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProute
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ProtoStringCrumbCrumb{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Crumb = &ProtoCrumb_StringCrumbCrumb{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProtoRoute) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProtoRoute: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProtoRoute: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TemplatePath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProute
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TemplatePath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Method", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProute
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Method = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PathCrumbs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProute
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PathCrumbs = append(m.PathCrumbs, ProtoCrumb{})
			if err := m.PathCrumbs[len(m.PathCrumbs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeaderCrumbs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProute
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HeaderCrumbs = append(m.HeaderCrumbs, ProtoCrumb{})
			if err := m.HeaderCrumbs[len(m.HeaderCrumbs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueryCrumbs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProute
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.QueryCrumbs = append(m.QueryCrumbs, ProtoCrumb{})
			if err := m.QueryCrumbs[len(m.QueryCrumbs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BodyCrumbs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProute
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BodyCrumbs = append(m.BodyCrumbs, ProtoCrumb{})
			if err := m.BodyCrumbs[len(m.BodyCrumbs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContentType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProute
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContentType = append(m.ContentType, ContentType(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProtoAPI) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProtoAPI: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProtoAPI: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field URL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProute
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.URL = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProute
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Routes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProute
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Routes = append(m.Routes, ProtoRoute{})
			if err := m.Routes[len(m.Routes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeaderCrumbs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProute
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HeaderCrumbs = append(m.HeaderCrumbs, ProtoCrumb{})
			if err := m.HeaderCrumbs[len(m.HeaderCrumbs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueryCrumbs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProute
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.QueryCrumbs = append(m.QueryCrumbs, ProtoCrumb{})
			if err := m.QueryCrumbs[len(m.QueryCrumbs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BodyCrumbs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProute
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BodyCrumbs = append(m.BodyCrumbs, ProtoCrumb{})
			if err := m.BodyCrumbs[len(m.BodyCrumbs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CookieCrumbs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProute
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CookieCrumbs = append(m.CookieCrumbs, ProtoCrumb{})
			if err := m.CookieCrumbs[len(m.CookieCrumbs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProtoAPIS) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProtoAPIS: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProtoAPIS: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field APIs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProute
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProute
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.APIs = append(m.APIs, ProtoAPI{})
			if err := m.APIs[len(m.APIs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipProute(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowProute
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowProute
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowProute
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthProute
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupProute
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthProute
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthProute        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowProute          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupProute = fmt.Errorf("proto: unexpected end of group")
)
